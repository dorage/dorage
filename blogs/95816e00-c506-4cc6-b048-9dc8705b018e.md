---
uuid: 95816e00-c506-4cc6-b048-9dc8705b018e
description: 
title: [1129]Â Shortest Path with Alternating Colors
tags: [ LeetCode, Medium ]
date: 2022-10-11T15:00:00.000Z
---







### ë§í¬

### ğŸ“ ë¬¸ì œ

You are given an integerÂ `n`, the number of nodes in a directed graph where the nodes are labeled fromÂ `0`Â toÂ `n - 1`. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.

You are given two arraysÂ `redEdges`Â andÂ `blueEdges`Â where:

- `redEdges[i] = [ai, bi]`Â indicates that there is a directed red edge from nodeÂ `ai`Â to nodeÂ `bi`Â in the graph, and
- `blueEdges[j] = [uj, vj]`Â indicates that there is a directed blue edge from nodeÂ `uj`Â to nodeÂ `vj`Â in the graph.

Return an arrayÂ `answer`Â of lengthÂ `n`, where eachÂ `answer[x]`Â is the length of the shortest path from nodeÂ `0`Â to nodeÂ `x`Â such that the edge colors alternate along the path, orÂ `-1`Â if such a path does not exist.

*INPUT*

*OUTPUT*

```jsx
n = 3, redEdges = [[0,1],[1,2]], blueEdges = []
```

```jsx
[0,1,-1]
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

```jsx
const COLOR = {
    RED : 'red',
    BLUE : 'blue',
    ALL : 'all'
}

const nextQIteratee = (color) => (e) => [e, color];

const makeGraph = (n, redEdges, blueEdges) => {
    const graph = Array(n).fill().map(()=>({[COLOR.RED]:[], [COLOR.BLUE]:[]}));
    
    const redLen = redEdges.length;
    const blueLen = blueEdges.length;
    const maxLen = Math.max(redLen, blueLen);
    for(let i = 0; i < maxLen; i++) {
        if(i < redLen) {
            const [a, b] = redEdges[i];
            graph[a][COLOR.RED].push(b);
        }
        if(i < blueLen) {
            const [a, b] = blueEdges[i];
            graph[a][COLOR.BLUE].push(b);
        }
    }
    
    return graph;
};

/**
 * @param {number} n
 * @param {number[][]} redEdges
 * @param {number[][]} blueEdges
 * @return {number[]}
 */
var shortestAlternatingPaths = function(n, redEdges, blueEdges) {
    const graph = makeGraph(n, redEdges, blueEdges);
    const answer = Array(n).fill(-1);
    let dist = 0;
    
    // BFS
    const q = [[0, COLOR.ALL]];
    const redVisited = new Set();
    const blueVisited = new Set();
    
    while(q.length) {
        const preq = [];
        while(q.length) {
            const [idx, color] = q.shift();
            
            if(answer[idx] === -1) answer[idx] = dist;
            
            if(color === COLOR.RED) {
                if(redVisited.has(idx)) continue;
                redVisited.add(idx);
                
                preq.push(...graph[idx][COLOR.BLUE].map(nextQIteratee(COLOR.BLUE)));
            } else if(color === COLOR.BLUE) {
                if(blueVisited.has(idx)) continue;
                blueVisited.add(idx);
                
                preq.push(...graph[idx][COLOR.RED].map(nextQIteratee(COLOR.RED)));
            } else {
                preq.push(...graph[idx][COLOR.BLUE].map(nextQIteratee(COLOR.BLUE)));
                preq.push(...graph[idx][COLOR.RED].map(nextQIteratee(COLOR.RED)));
            }
        }
        dist++;
        q.push(...preq);
    }
    
    return answer;
};
```