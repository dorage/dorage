---
uuid: 29633835-6856-4a2a-8bc8-66fc5648b0c6
description: 
title: [33]Â Search in Rotated Sorted Array
tags: [ LeetCode, Medium ]
date: 2022-09-20T15:00:00.000Z
---







### ë§í¬

[Sum of Even Numbers After Queries - LeetCode](https://leetcode.com/problems/sum-of-even-numbers-after-queries/)

### ğŸ“ ë¬¸ì œ

There is an integer arrayÂ `nums`Â sorted in ascending order (withÂ **distinct**Â values).

Prior to being passed to your function,Â `nums`Â isÂ **possibly rotated**Â at an unknown pivot indexÂ `k`Â (`1 <= k < nums.length`) such that the resulting array isÂ `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`Â (**0-indexed**). For example,Â `[0,1,2,4,5,6,7]`Â might be rotated at pivot indexÂ `3`Â and becomeÂ `[4,5,6,7,0,1,2]`.

Given the arrayÂ `nums`Â **after**Â the possible rotation and an integerÂ `target`, returnÂ *the index of*Â `target`Â *if it is in*Â `nums`*, or*Â `-1`Â *if it is not in*Â `nums`.

You must write an algorithm withÂ `O(log n)`Â runtime complexity.

*INPUT*

*OUTPUT*

```jsx
nums = [4,5,6,7,0,1,2], target = 0
```

```jsx
4
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

```jsx
const findRotatePivot = (arr) => {
    let pivot = 0;
    for(let i = 1; i < arr.length; i++) {
        if(arr[i] > arr[i - 1]) continue;
        pivot = i;
        break;
    }
    return pivot;
};

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    const k = findRotatePivot(nums);
    
    let l = 0;
    let r = nums.length;
    
    while(l <= r) {
        const mid = Math.floor((l + r) / 2);
        const pivotMid = (mid + k) % nums.length;
        
        if(nums[pivotMid] === target) return pivotMid;
        if(nums[pivotMid] > target) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    
    return -1;
};
```