---
uuid: 2842f2f8-3b66-4c54-aac6-a731ac89b3f1
description: 
title: [11437] LCA
tags: [  ]
date: 2022-01-15T15:00:00.000Z
---







### ë§í¬

[https://www.acmicpc.net/problem/11437](https://www.acmicpc.net/problem/11437)

### ğŸ“ ë¬¸ì œ

*INPUT*

*OUTPUT*

```jsx
15
1 2
1 3
2 4
3 7
6 2
3 8
4 9
2 5
5 11
7 13
10 4
11 15
12 5
14 7
6
6 11
10 9
2 6
7 6
8 13
8 15
```

```jsx
2
4
2
1
3
1
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

#1  íŠ¸ë¦¬ë¥¼ ë§Œë“  ë’¤ í•œ ì •ì ì—ì„œì˜ ëª¨ë“  ì¡°ìƒì„ ë°°ì—´ì— ë„£ê³  ë‹¤ìŒ ì •ì ì„ ìˆœíšŒí•˜ë©° ê°€ì¥ ë¨¼ì € ì¤‘ë³µë˜ëŠ” ì •ì ì„ ë°°ì—´ì— ë‹´ëŠ” í˜•ì‹ìœ¼ë¡œ í’€ì´í•˜ì˜€ë‹¤. [ì‹œê°„ì´ˆê³¼]

```jsx
const readline = require('readline');

let input = [];

readline
    .createInterface({
        input: process.stdin,
        output: process.stdout,
    })
    .on('line', function (line) {
        input.push(line);
    })
    .on('close', function () {
        solution(input);
        process.exit();
    });

function solution(input) {
    const n = Number(input.shift());
    const tree = makeTree(n, input.splice(0, n - 1));

    const m = Number(input.shift());
    const result = [];
    for (const line of input) {
        const [i, j] = line.split(' ').map(Number);
        const leftParents = [];
        let node = tree[i];
        while (node !== -1) {
            leftParents.push(node);
            node = node.parent;
        }
        node = tree[j];
        while (node !== -1) {
            if (leftParents.includes(node)) {
                result.push(node.id);
                break;
            }
            node = node.parent;
        }
    }
    console.log(result.join('\n'));
}

function makeTree(n, input) {
    const tree = [];
    const graph = [];

    for (let i = 1; i < n + 1; i++) {
        tree[i] = Node(i);
        if (i === 1) tree[i].parent = -1;
    }

    for (const line of input) {
        const [n1, n2] = line.split(' ').map(Number);
        if (!graph[n1]) graph[n1] = [];
        if (!graph[n2]) graph[n2] = [];
        graph[n1].push(n2);
        graph[n2].push(n1);
    }

    const queue = [1];
    while (queue.length) {
        const id = queue.shift();
        for (const adjacentId of graph[id]) {
            if (!tree[adjacentId].parent) {
                tree[adjacentId].parent = tree[id];
                queue.push(adjacentId);
            }
        }
    }

    return tree;
}

function Node(id) {
    if (!new.target) return new Node(id);
    this.id = id;
    this.parent = null;
}
```

#2 LCA ì•Œê³ ë¦¬ì¦˜ì´ë€ê²Œ ìˆëŠ”ê°€ë³´ë‹¤

ì‹œê°„ë³µì¡ë„ O(log n)ì„ ê°–ëŠ” LCAì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•´ ì•Œì•„ë³´ì•˜ë‹¤.

ê°™ì€ ë ˆë²¨ê¹Œì§€ ë§ì¶°ì¤€ í›„ ê°™ì´ ë¶€ëª¨ë¡œ ì˜¬ë¼ê°€ë©° ì¼ì¹˜í•˜ëŠ” ë…¸ë“œë¥¼ ì°¾ëŠ” ë°©ì‹ì´ë‹¤.

```jsx
const readline = require('readline');

let input = [];

readline
    .createInterface({
        input: process.stdin,
        output: process.stdout,
    })
    .on('line', function (line) {
        input.push(line);
    })
    .on('close', function () {
        solution(input);
        process.exit();
    });

function solution(input) {
    const n = Number(input.shift());
    const tree = makeTree(n, input.splice(0, n - 1));

    const m = Number(input.shift());
    const result = [];
    for (const line of input) {
        const [i, j] = line.split(' ').map(Number);
        let node1 = tree[i];
        let node2 = tree[j];
        while (node1.level !== node2.level) {
            if (node1.level < node2.level) {
                node2 = node2.parent;
            } else {
                node1 = node1.parent;
            }
        }
        while (node1.id !== node2.id) {
            node1 = node1.parent;
            node2 = node2.parent;
        }
        result.push(node1.id);
    }
    console.log(result.join('\n'));
}

function makeTree(n, input) {
    const tree = [];
    const graph = [];

    for (let i = 1; i < n + 1; i++) {
        tree[i] = Node(i);
        if (i === 1) {
            tree[i].parent = -1;
            tree[i].level = 1;
        }
    }

    for (const line of input) {
        const [n1, n2] = line.split(' ').map(Number);
        if (!graph[n1]) graph[n1] = [];
        if (!graph[n2]) graph[n2] = [];
        graph[n1].push(n2);
        graph[n2].push(n1);
    }

    const queue = [1];
    while (queue.length) {
        const id = queue.shift();
        for (const adjacentId of graph[id]) {
            if (!tree[adjacentId].parent) {
                tree[adjacentId].parent = tree[id];
                tree[adjacentId].level = tree[id].level + 1;
                queue.push(adjacentId);
            }
        }
    }

    return tree;
}

function Node(id) {
    if (!new.target) return new Node(id);
    this.id = id;
    this.parent = null;
    this.level = 0;
}
```