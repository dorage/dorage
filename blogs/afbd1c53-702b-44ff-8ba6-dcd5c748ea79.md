---
uuid: afbd1c53-702b-44ff-8ba6-dcd5c748ea79
description: 
title: [212]Â Word Search II
tags: [ Daily Challenge, Hard, LeetCode ]
date: 2022-11-04T15:00:00.000Z
---







### ë§í¬

[Word Search II - LeetCode](https://leetcode.com/problems/word-search-ii/)

### ğŸ“ ë¬¸ì œ

Given anÂ `m x n`Â `board`Â of characters and a list of stringsÂ `words`, returnÂ *all words on the board*.

Each word must be constructed from letters of sequentially adjacent cells, whereÂ **adjacent cells**Â are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

![Untitled](https://vault-r2.dorage.io/afbd1c53-702b-44ff-8ba6-dcd5c748ea79/untitled.png)

*INPUT*

*OUTPUT*

```jsx
board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
```

```jsx
["eat","oath"]
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

ì²˜ìŒì—” ë¶™ì–´ìˆëŠ” ì—°ì†ëœ ìœ„ì¹˜ì— ìˆëŠ” Stringì„ ì‡ëŠ” ë¬¸ì œì—¬ì„œ Trieì¸ê°€ ì‹¶ì—ˆë‹¤.

í•˜ì§€ë§Œ Case1ì„ ì˜ ë³´ë‹ˆ ë‹¨ìˆœíˆ ê°€ë¡œ, ì„¸ë¡œê°€ ì•„ë‹ˆë¼ êº¾ì¼ ìˆ˜ë„ ìˆê³  ì—­ìˆœìœ¼ë¡œ ë°°ì¹˜ë  ìˆ˜ë„ ìˆë‹¤.

ì‚¬ì‹¤ ì—­ìˆœìœ¼ë¡œ ë°°ì¹˜ëœ ë¬¸ìì—´ë„ Matrixë¥¼ ì—­ë°©í–¥ìœ¼ë¡œ ìˆœíšŒí•˜ë©´ì„œ Trieì— ë‹´ìœ¼ë©´ í’€ì´í•  ìˆ˜ ìˆì§€ë§Œ ì¢Œë¡œ êº¾ê³  ìš°ë¡œ êº¾ëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ Trieì— ë„£ëŠ” ê²ƒì€ í˜ë“¤ ê²ƒ ê°™ë‹¤.

ê·¸ë˜ì„œ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ BFSë¥¼ í•˜ë©´ ì‰½ê²Œ í’€ ìˆ˜ ìˆì„ ê²ƒì´ë€ ìƒê°ì´ ë“¤ì—ˆë‹¤.

ë˜í•œ, ê° ì•ŒíŒŒë²³ì˜ ì‹œì‘ ì ì´ í•„ìš”í•˜ë‹ˆ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ìˆœíšŒí•˜ë©´ì„œ ì‹œì‘ ì ì„ ë‹´ìœ¼ë©´ ë  ê²ƒ ê°™ë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤.

ì²˜ìŒì—” ì•„ë˜ì²˜ëŸ¼ í’€ì´í•´ë³´ì•˜ë‹¤. ë‹¤ë§Œ ì—¬ê¸°ì„œ ë¬¸ì œì ì´ ë¬´ì—‡ì´ëƒ í•˜ë©´ [[â€aâ€,â€aâ€]] ê°€ ì£¼ì–´ì¡Œì„ ë•Œ wordê°€ â€œaaâ€ë¼ í•˜ë©´ BFSë¡œ í’€ì´í•  ë•Œ â€œaaâ€ë¥¼ ê°™ì€ íšŒì°¨ì˜ íì— ë„£ë‹¤ ë³´ë‹ˆ ë‘˜ ë‹¤ visitedì— ë“¤ì–´ê°€ì„œ ê²°ê³¼ì ìœ¼ë¡œ ë‹¤ìŒ íƒìƒ‰í•  ìˆ˜ ìˆëŠ” ìˆ˜ê°€ ì‚¬ë¼ì§„ë‹¤ëŠ” ì ì´ë‹¤.

ë”°ë¼ì„œ ì´ëŠ” DFSë¡œ í’€ì´í•´ì•¼ í•  ê²ƒ ê°™ë‹¤.

```jsx
const getMN = (board) => [board.length, board[0].length];
const charCode = (c) => c.charCodeAt() - 'a'.charCodeAt();

const Node = function (c) {
    if(!new.target) return new Node(c);
    this.c = c;
    this.adj = [];
}

const makeLinkedMap = (board) => {
    const [m, n] = getMN(board);
    const map = Array(m).fill().map(()=>Array(n));
    const charmap = {};

    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            const c = board[i][j];
            const node = new Node(c);
            map[i][j] = node;

            if(!charmap[c]) charmap[c] = [];
            charmap[c].push(node);
            
            if(i > 0) {
                node.adj.push(map[i - 1][j]);
                map[i - 1][j].adj.push(node);
            }
            if(j > 0) {
                node.adj.push(map[i][j - 1]);
                map[i][j - 1].adj.push(node);
            }
        }
    }

    return charmap;
};

const searchWord = (map) => (word) => {
    if(map[word[0]] == null) return false;
    const n = word.length
    const q = [...map[word[0]]];
    const visited = new Set();
    
    let cursor = 0;

    while(q.length) {
        const preq = [];
        cursor++;

        while(q.length) {
            const node = q.shift();
            
            if(visited.has(node)) continue;
            visited.add(node);
            if(cursor >= n) return true;

            for(const candidate of node.adj){
                if(candidate.c === word[cursor]){
                    preq.push(candidate);
                }
            }
        }
    
        q.push(...preq);
    }

    return false;
}

/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
    const map = makeLinkedMap(board);
    return words.filter(searchWord(map))
};
```

ê·¸ëŸ°ë° ê²°êµ­ TLEë¥¼ ë§ì•˜ë‹¤

```
const getMN = (board) => [board.length, board[0].length];
const charCode = (c) => c.charCodeAt() - 'a'.charCodeAt();

// ì‹œì‘ì ì„ ìœ„í•´ ê° ì•ŒíŒŒë²³ ë³„ ìœ„ì¹˜ ì¸ë±ìŠ¤ë¥¼ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ë©´ì„œ ë‹´ì•„ì£¼ê¸°
// ì–‘ë°©í–¥ ë§í¬ë“œë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ì„œ BFS ë¥¼ ì‹œë„í•˜ëŠ”ê²Œ ë” ë‚˜ì„ ê²ƒ ê°™ë‹¤ëŠ” ìƒê°ì´ ë“¬

const Node = function (c) {
    if(!new.target) return new Node(c);
    this.c = c;
    this.adj = [];
}

const makeLinkedMap = (board) => {
    const [m, n] = getMN(board);
    const map = Array(m).fill().map(()=>Array(n));
    const charmap = {};

    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            const c = board[i][j];
            const node = new Node(c);
            map[i][j] = node;

            if(!charmap[c]) charmap[c] = [];
            charmap[c].push(node);
            
            if(i > 0) {
                node.adj.push(map[i - 1][j]);
                map[i - 1][j].adj.push(node);
            }
            if(j > 0) {
                node.adj.push(map[i][j - 1]);
                map[i][j - 1].adj.push(node);
            }
        }
    }
    
    return charmap;
};

const DFS = (node, word, cursor, visited = new Set()) => {
    if(cursor >= word.length) return true;
    if(node.c !== word[cursor]) return false;
    if(visited.has(node)) return false;
    
    return node.adj.some((next)=> DFS(next, word, cursor + 1, new Set([...visited, node])));
};

const searchWord = (map) => (word) => {
    if(map[word[0]] == null) return false;
    if(word.length === 1) return true;

    for(const node of map[word[0]]) {
        if(DFS(node, word, 0)) return true;
    }
    return false;
}

/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
    const map = makeLinkedMap(board);
    return words.filter(searchWord(map))
}
```

í’€ì´ë²•ì„ ë³´ë‹ˆ Trieë¥¼ ì‚¬ìš©í•˜ëŠ”ë° Trieë¥¼ ë°˜ëŒ€ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒ ê°™ë‹¤.

wordsë¥¼ trieë¡œ ë§Œë“¤ì–´ì„œ matrixë¥¼ ìˆœíšŒí•˜ë©´ì„œ DPSë¥¼ ì§„í–‰í•´ í•´ë‹¹ì´ ë˜ëŠ” ê²½ìš°ì—ë§Œ resultì— ë‹´ìœ¼ë©´ ë˜ëŠ” ê²ƒ ê°™ë‹¤.

ë˜í•œ, ì´ë¯¸ íƒìƒ‰ì´ ì™„ë£Œëœ TrieëŠ” ì‚­ì œí•˜ëŠ” ê²ƒìœ¼ë¡œ ì¤‘ë³µëœ ê²€ì‚¬ë¥¼ í”¼í•œë‹¤.

```jsx
const getMN = (board) => [board.length, board[0].length];
const idxToStr = ([i, j]) => `${i} ${j}`;

const Trie = function() {
    if(!new.target) return new Trie();
    this.isEnd = false;
    this.next = {};
}
Trie.prototype.delete = function(word) {
    const n = word.length;
    const nodes = [this];
    
    let curr = this;
    for(const c of word) {
        nodes.push(curr.next[c]);
        curr = curr.next[c];
    }

    nodes.at(-1).isEnd = false;

    for(let i = n - 1; i > 0; i--) {
        const c = word[i];
        const curr = nodes.pop();
        if(Object.keys(curr.next).length) break;
        delete nodes.at(-1).next[c];
    }
}

const makeTrie = (words) => {
    const trie = new Trie();

    for(const word of words) {
        let curr = trie;
        for(const c of word) {
            if(curr.next[c] == null) curr.next[c] = new Trie();
            curr = curr.next[c];
        }
        curr.isEnd = true;
    }
    
    return trie;
};

/**
 * @param {character[][]} board
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(board, words) {
    const result = new Set();
    const [m, n] = getMN(board);
    const trie = makeTrie(words);

    const DFS = (curr, coord, word, visited) => {
        const [i, j] = coord;
        const c = board[i][j];
        
        // visited ì²´í¬
        if(visited.has(idxToStr(coord))) return;
        visited.add(idxToStr(coord));
        
        word += c;
        if(curr?.next[c] == null) return;
        if(curr.next[c].isEnd) {
            result.add(word);
            trie.delete(word);
        }

        if(i - 1 >= 0) DFS(curr.next[c], [i - 1, j], word, new Set([...visited]));
        if(j - 1 >= 0) DFS(curr.next[c], [i, j - 1], word, new Set([...visited]));
        if(i + 1 < m) DFS(curr.next[c], [i + 1, j], word, new Set([...visited]));
        if(j + 1 < n) DFS(curr.next[c], [i, j + 1], word, new Set([...visited]));
    }

    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            if(trie.next[board[i][j]] == null) continue;
            DFS(trie, [i, j], '', new Set());
        }
    }
    
    return [...result];
};
```