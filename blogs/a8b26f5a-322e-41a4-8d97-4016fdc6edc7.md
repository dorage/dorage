---
uuid: a8b26f5a-322e-41a4-8d97-4016fdc6edc7
description: 
title: [1987]Â Number of Unique Good Subsequences
tags: [ Hard, LeetCode ]
date: 2022-11-02T15:00:00.000Z
---







### ë§í¬

[Number of Unique Good Subsequences - LeetCode](https://leetcode.com/problems/number-of-unique-good-subsequences/)

### ğŸ“ ë¬¸ì œ

You are given a binary stringÂ `binary`. AÂ **subsequence**Â ofÂ `binary`Â is consideredÂ **good**Â if it isÂ **not empty**Â and hasÂ **no leading zeros**Â (with the exception ofÂ `"0"`).

Find the number ofÂ **unique good subsequences**Â ofÂ `binary`.

- For example, ifÂ `binary = "001"`, then all theÂ **good**Â subsequences areÂ `["0", "0", "1"]`, so theÂ **unique**Â good subsequences areÂ `"0"`Â andÂ `"1"`. Note that subsequencesÂ `"00"`,Â `"01"`, andÂ `"001"`Â are not good because they have leading zeros.

ReturnÂ *the number ofÂ **unique good subsequences**Â of*Â `binary`. Since the answer may be very large, return itÂ **modulo**Â `109Â + 7`.

AÂ **subsequence**Â is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

*INPUT*

*OUTPUT*

```jsx
binary = "001"
```

```jsx
2
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

íƒ‘-ë‹¤ìš´ ë°©ì‹ìœ¼ë¡œ í’€ì´í–ˆëŠ”ë° ì´ëŸ° ì‹ìœ¼ë¡œ í’€ì´ë¥¼ í•´ë³´ë‹ˆ ë„ˆë¬´ ë§ì€ ì—°ì‚°ì„ í•˜ê³  ìˆëŠ” ê²ƒ ê°™ë‹¤.

í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ë§Œë“¤ì–´ "101010101010101010â€ n = 18ì¼ ë•Œ, ì¹´ìš´íŠ¸ê°€ 131,110 ì´ë‹¤.

ë” ëŠ˜ë ¤ì„œ n = 24ë¡œ ë³´ì•˜ì„ ë•Œ, ì—°ì‚° íšŸìˆ˜ê°€ 3,000,000 ì„ ë„˜ëŠ”ë‹¤.

ë°”í…€-ì—… ë°©ì‹ìœ¼ë¡œ í’€ì´ë¥¼ ìƒê°í•´ë³´ì•˜ëŠ”ë° ë§ì„ì§€ ëª¨ë¥´ê² ë‹¤.

```jsx
/**
 * @param {string} binary
 * @return {number}
 */
var numberOfUniqueGoodSubsequences = function(binary) {
    const MOD = 10 ** 9 + 7;
    let result = 0;
    let count = 0;
    const q = [binary];
    
    while(q.length) {
        const preq = new Set();
        const unique = new Set();
        while(q.length) {
            const bin = q.shift();
            
            if(!bin.length) continue;
            if(bin.length === 1 || bin[0] !== '0') unique.add(bin);
            
            for(let i = 0; i < bin.length; i++) {
                count++;
                const next = bin.slice(0, i) + bin.slice(i + 1, bin.length);
                preq.add(next);
            }
        }
        q.push(...[...preq]);
    }
    console.log(count);
    return result;
};
```

ë‹¤ìŒì€ ë°”í…€-ì—… ë°©ì‹ìœ¼ë¡œ í’€ì´í•´ë³¸ ë‹µì´ë‹¤.

ë°”í…€-ì—… ë°©ì‹ìœ¼ë¡œ í’€ì´ë¥¼ í•´ë³´ì•˜ì„ ë•ŒëŠ” ë™ì¼í•œ n = 24 ê¸°ì¤€ â€œ101010101010101010101010â€ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì— ëŒ€í•´ 392,860 ë¡œ ì—°ì‚° íšŸìˆ˜ê°€ 1/10ìœ¼ë¡œ ì¤„ì–´ë“¤ì—ˆë‹¤.

í•˜ì§€ë§Œ ì—¬ì „íˆ n = 30ê¹Œì§€ë§Œ ê°€ë„ TLEê°€ ë°œìƒí•œë‹¤.

ê·¸ë˜ì„œ ë” ì¤„ì¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì„ ìƒê°í•´ ë³´ë‹¤ ëª¨ë“  0ê³¼ 1ì˜ ì¸ë±ìŠ¤ë¥¼ êµ¬í•´ì„œ íƒìƒ‰ì„ í•˜ë©´ ë” ë¹ ë¥´ì§€ ì•Šì„ê¹Œ ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤.

```jsx
let count = 0;

const findBins = (binary, start) => {
    const q = [-1, -1];
    
    for(let i = start - 1; i >= 0; i --) {
        count++;
        if(binary[i] === "0" && q[0] === -1) q[0] = i;
        if(binary[i] === "1" && q[1] === -1) q[1] = i;
        if(q[0] >= 0 && q[1] >= 0) break;
    }
    
    return q.filter(e => e !== -1);
};

/**
 * @param {string} binary
 * @return {number}
 */
var numberOfUniqueGoodSubsequences = function(binary) {
    const n = binary.length
    const MOD = 10 ** 9 + 7;
    
    const q = findBins(binary, n);
    let result = binary[q[0]] === "0" ? 1 : 0;
    
    while(q.length) {
        const curr = q.shift();
        
        if(binary[curr] === "1") {
            result += 1;
            result %= MOD;
        }
        
        q.push(...findBins(binary, curr));
        
        count++;
    }
    
    console.log(count);
    return result % MOD;
};
```