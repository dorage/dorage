---
uuid: 149c2526-68d4-46ca-a738-9ba7991cac2a
description: 
title: [207]Â Course Schedule
tags: [ LeetCode, Medium ]
date: 2022-09-07T15:00:00.000Z
---







### ë§í¬

[Course Schedule - LeetCode](https://leetcode.com/problems/course-schedule/)

### ğŸ“ ë¬¸ì œ

There are a total ofÂ `numCourses`Â courses you have to take, labeled fromÂ `0`Â toÂ `numCourses - 1`. You are given an arrayÂ `prerequisites`Â whereÂ `prerequisites[i] = [ai, bi]`Â indicates that youÂ **must**Â take courseÂ `bi`Â first if you want to take courseÂ `ai`.

- For example, the pairÂ `[0, 1]`, indicates that to take courseÂ `0`Â you have to first take courseÂ `1`.

ReturnÂ `true`Â if you can finish all courses. Otherwise, returnÂ `false`.

*INPUT*

*OUTPUT*

```jsx

```

```jsx

```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

DFSë¡œ í’€ì´í•˜ì˜€ë‹¤.

BFS í’€ì´ ë°©ë²•ì„ ì°¾ì•„ë³´ì•„ì•¼ê² ë‹¤

```tsx
class Node {
    val = 0;
    children = [];
    constructor(n:number){
        this.val = n;
    }
    addChild(node:Node){
        this.children.push(node);
    }
}

function canFinish(numCourses: number, prerequisites: number[][]): boolean {
    const nodes: (Node|undefined)[] = Array(numCourses);
    const visited: (boolean|undefined)[] = Array(numCourses).fill(false);
    for(let i = 0; i < numCourses; i++){
        nodes[i] = new Node(i);
    }
    for(const [a, b] of prerequisites){
        nodes[b].addChild(nodes[a]);
    }
    for(let i = 0; i < numCourses; i++){
        if(visited[i]) continue;
        if(!DFS(nodes[i], visited, {})) return false;
    }
    return true;
};

const DFS = (node:Node, visited:boolean[], path:any): boolean => {
    if(path[node.val]) return false;
    if(visited[node.val]) return true;
    path[node.val] = true;
    visited[node.val] = true;
    const answer = [];
    for(const child of node.children){
        answer.push(DFS(child, visited, {...path}));
    }
    return answer.every((e)=>e);
}
```

DFS ë³´ì™„, pathëŒ€ì‹  visitedì˜ ê°’ì— ë”°ë¼ ì¸¡ì •

```tsx
class Node {
    val = 0;
    children = [];
    constructor(n:number){
        this.val = n;
    }
    addChild(node:Node){
        this.children.push(node);
    }
}

function canFinish(numCourses: number, prerequisites: number[][]): boolean {
    const nodes: (Node|undefined)[] = Array(numCourses);
    const visited: number[] = Array(numCourses).fill(0);
    for(let i = 0; i < numCourses; i++){
        nodes[i] = new Node(i);
    }
    for(const [a, b] of prerequisites){
        nodes[b].addChild(nodes[a]);
    }
    for(let i = 0; i < numCourses; i++){
        if(visited[i]) continue;
        if(!DFS(nodes[i], visited)) return false;
    }
    return true;
};

const DFS = (node:Node, visited:number[]): boolean => {
    if(visited[node.val] === -1) return false;
    if(visited[node.val] === 1) return true;
    visited[node.val] = -1;
    for(const child of node.children){
        if(!DFS(child, visited)) return false;
    }
    visited[node.val] = 1;
    return true;
}
```

í´ë˜ìŠ¤ë„ í•„ìš” ì—†ëŠ” ê²ƒ ê°™ì•„ì„œ í´ë˜ìŠ¤ë„ ì‚­ì œ í•´ë²„ë ¸ë‹¤

```tsx
function canFinish(numCourses: number, prerequisites: number[][]): boolean {
    const nodes: number[][] = Array(numCourses).fill(0).map(()=>[]);
    const visited: number[] = Array(numCourses).fill(0);
    
    for(const [a, b] of prerequisites){
        nodes[b].push(a);
    }
    
    for(let i = 0; i < numCourses; i++){
        if(visited[i]) continue;
        if(!DFS(nodes, visited, i)) return false;
    }
    return true;
};

const DFS = (nodes:number[][], visited:number[], i:number): boolean => {
    if(visited[i] === -1) return false;
    if(visited[i] === 1) return true;
    visited[i] = -1;
    for(const child of nodes[i]){
        if(!DFS(nodes, visited, child)) return false;
    }
    visited[i] = 1;
    return true;
}
```

BFS í’€ì´ë°©ë²•

ì°¨ìˆ˜ë¥¼ ì´ìš©í•´ í’€ì´í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ë°©ë¬¸ì„ í•  ë•Œë§ˆë‹¤ indegreeë¥¼ 1ì”© ì¤„ì—¬ 0ì´ ë˜ëŠ” ê²½ìš° íì— ë‹´ëŠ” ë°©ì‹ìœ¼ë¡œ ì‚¬ì´í´ì´ í˜•ì„±ë˜ëŠ” ê³³ì€ ì°¨ìˆ˜ê°€ 1ì´ ëª¨ìë¼ íì— ë‹´ê¸°ì§€ ëª»í•˜ê³  ê²°êµ­ íƒìƒ‰í•œ ë…¸ë“œ íšŸìˆ˜ëŠ” ì²˜ìŒ ì£¼ì–´ì§„ numCoursesê°€ ë  ìˆ˜ ì—†ë‹¤.

[Intuitive JavaScript with BFS - LeetCode Discuss](https://leetcode.com/problems/course-schedule/discuss/612288/Intuitive-JavaScript-with-BFS)

```tsx
function canFinish(numCourses: number, prerequisites: number[][]): boolean {
    const nodes:number[][] = Array(numCourses).fill(0).map(() => []);
    const indegree:number[] = Array(numCourses).fill(0);
    
    for(const [t, f] of prerequisites){
        nodes[f].push(t);
        indegree[t]++;
    }
    
    const queue:number[] = []
    indegree.forEach((e, t) => {
        if(e === 0) queue.push(t);
    });
    
    let count = queue.length;
    while(queue.length){
        const i = queue.shift();
        for(const t of nodes[i]){
            indegree[t]--;
            if(indegree[t] === 0) {
                queue.push(t);
                count++;
            }
        }
    }
    return count === numCourses;
};
```