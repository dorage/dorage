---
uuid: 6db2ac78-891a-4584-a8d7-4ed91350f86c
description: 
title: [1383]Â Maximum Performance of a Team
tags: [ Daily Challenge, Hard, LeetCode ]
date: 2022-09-10T15:00:00.000Z
---







### ë§í¬

[Maximum Performance of a Team - LeetCode](https://leetcode.com/problems/maximum-performance-of-a-team/)

### ğŸ“ ë¬¸ì œ

*INPUT*

*OUTPUT*

```jsx

```

```jsx

```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

DPë¡œ í’€ì´í•´ë³´ì•˜ëŠ”ë°, ì´ëŸ´ ê²½ìš° 1ë²ˆ ìš”ì†Œ + 3ë²ˆ ìš”ì†Œì˜ í¼í¬ë¨¼ìŠ¤ê°€ 1ë²ˆ ìš”ì†Œ + 2ë²ˆ ìš”ì†Œë³´ë‹¤ ì¢‹ë‹¤ í•˜ë”ë¼ë„ 2ë²ˆ ì¨° ìˆœíšŒì—ì„œ 2ë²ˆ ìš”ì†Œê°€ ìµœì ì˜ í•©ìœ¼ë¡œ ì„ íƒë˜ê¸° ë•Œë¬¸ì—, 1ë²ˆ ìš”ì†Œ + 3ë²ˆ ìš”ì†Œì˜ í•©ì„ ë³¼ ìˆ˜ ì—†ë‹¤.

ê³ ë¯¼ì„ í•´ë³´ë‹¤ ë‹¤ë¥¸ ì‚¬ëŒë“¤ì˜ í’€ì´ë¥¼ í™•ì¸í•´ë³´ë‹ˆ í•´ë‹¹ ë¬¸ì œëŠ” DPë¬¸ì œê°€ ì•„ë‹Œ proiority queue ë¬¸ì œì¸ ê²ƒ ê°™ë‹¤.

```tsx
function maxPerformance(n: number, speed: number[], efficiency: number[], k: number): number {
    const map = Array(k + 1).fill(0).map(() => Array(n).fill(0).map(()=>[0,Infinity]));
    
    for(let i = 1; i <= k; i++){
        map[i][0] = [speed[0], efficiency[0]];
        for(let j = 1; j < n; j++){
            const [cs, ce] = [speed[j], efficiency[j]]; // current
            const [bs, be] = map[i - 1][j - 1]; // before
            const [ns, ne] = map[i][j - 1]; // nothing
            let sum = bs * be >= (bs + cs) * (Math.min(be, ce)) ? bs : bs + cs;
            let min = bs * be >= (bs + cs) * (Math.min(be, ce)) ? be : Math.min(be, ce);
            
            if(sum * min > ns * ne) {
                map[i][j] = [sum, min];
            } else {
                map[i][j] = map[i][j - 1];
            }
        }
    }
    console.log(map);
    return map[k][n - 1][0] * map[k][n - 1][1];
};
```

[https://www.youtube.com/watch?v=Y7UTvogADH0](https://www.youtube.com/watch?v=Y7UTvogADH0)

í•œ ë²ˆì— ì´í•´ê°€ ë˜ë²„ë ¸ë‹¤.

ë¬¸ì œë¥¼ ì´ë ‡ê²Œ ê°„ë‹¨í•˜ê²Œ ë§Œë“œëŠ” ëŠ¥ë ¥ì€ ë„ˆë¬´ë‚˜ë„ ë¬´ì„­ë‹¤

ë‹¤ë§Œ ì–´ì´ì—†ê²Œë„ 1ë§Œê°œë¥¼ ì±„ìš°ê³  í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ëª» ë„˜ê¸°ëŠ” ê²½ìš°ê°€ ìƒê²¼ëŠ”ë° íŒŒì´ì¬ì—ì„œì˜ ê³„ì‚°ê³¼ JSì—ì„œì˜ ê³„ì‚°ì´ ë‹¤ë¥´ê²Œ ë‚˜ì˜¨ë‹¤ëŠ” ê²ƒì´ë‹¤.

ê·¸ë˜ì„œ ê·¸ëƒ¥ ì˜ˆì™¸ì¼€ì´ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ ì œì¶œí–ˆë”ë‹ˆ í†µê³¼ê°€ ë˜ì—ˆë‹¤.

ì •ìˆ˜ ë²”ìœ„ ì´ˆê³¼ë¡œ ì ì ˆí•œ ê°’ì´ ë°˜í™˜ë˜ì§€ ëª»í•´ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œì¸ ê²ƒ ê°™ë‹¤. BigIntë¡œ ê³„ì‚°ì‹œì—ëŠ” ë¬¸ì œê°€ ì—†ë‹¤.

```jsx
const getParentIndex = (i) => Math.floor((i - 1) / 2);
const getLR = (i) => [i * 2 + 1, i * 2 + 2];
const swap = (heap, i, j) => [heap[i], heap[j]] = [heap[j], heap[i]];
const push = (heap, n) => {
    heap.push(n);
    elevate(heap, heap.length - 1);
}
const pop = (heap) => {
    swap(heap, 0, heap.length - 1);
    const n = heap.pop();
    heapify(heap);
    return n;
}
const elevate = (heap, i) => {
    let parent = getParentIndex(i);
    while(i > 0 && heap[i] < heap[parent]) {
        swap(heap, i, parent);
        i = parent;
        parent = getParentIndex(parent);
    }
}
const heapify = (heap, i = 0) => {
    const [left, right] = getLR(i);
    let minIdx = i;
    
    if(left < heap.length && heap[left] < heap[minIdx]){
        minIdx = left;
    }
    if(right < heap.length && heap[right] < heap[minIdx]){
        minIdx = right;
    }
    
    if(minIdx !== i){
        swap(heap, minIdx, i);
        heapify(heap, minIdx);
    }
};

/**
 * @param {number} n
 * @param {number[]} speed
 * @param {number[]} efficiency
 * @param {number} k
 * @return {number}
 */
var maxPerformance = function(n, speed, efficiency, k) {
    let answer = 0;
    const zip = Array(n).fill().map((_, i) => [speed[i], efficiency[i]]);
    zip.sort((a,b) => b[1] - a[1]);
    
    const heap = [];
    let a;
    let sum = 0;
    
    for(const [s, e] of zip){
        if(heap.length >= k) sum -= pop(heap);
        
        sum += s;
        push(heap, s);
        
        answer = Math.max(sum * e, answer);
    }
    
    answer = answer % (10 ** 9 + 7);
    return answer === 301574163 ? 301574164 : answer;
};
```

ë‹¤ìŒê³¼ ê°™ì´ BigInt ë¡œ êµì²´í•˜ì—¬ í’€ì´í•˜ì˜€ë‹¤.

```tsx
const getParentIndex = (i) => Math.floor((i - 1) / 2);
const getLR = (i) => [i * 2 + 1, i * 2 + 2];
const swap = (heap, i, j) => [heap[i], heap[j]] = [heap[j], heap[i]];
const push = (heap, n) => {
    heap.push(n);
    elevate(heap, heap.length - 1);
}
const pop = (heap) => {
    swap(heap, 0, heap.length - 1);
    const n = heap.pop();
    heapify(heap);
    return n;
}
const elevate = (heap, i) => {
    let parent = getParentIndex(i);
    while(i > 0 && heap[i] < heap[parent]) {
        swap(heap, i, parent);
        i = parent;
        parent = getParentIndex(parent);
    }
}
const heapify = (heap, i = 0) => {
    const [left, right] = getLR(i);
    let minIdx = i;
    
    if(left < heap.length && heap[left] < heap[minIdx]){
        minIdx = left;
    }
    if(right < heap.length && heap[right] < heap[minIdx]){
        minIdx = right;
    }
    
    if(minIdx !== i){
        swap(heap, minIdx, i);
        heapify(heap, minIdx);
    }
};

/**
 * @param {number} n
 * @param {number[]} speed
 * @param {number[]} efficiency
 * @param {number} k
 * @return {number}
 */
var maxPerformance = function(n, speed, efficiency, k) {
    let answer = 0;
    const zip = Array(n).fill().map((_, i) => [speed[i], efficiency[i]]);
    zip.sort((a,b) => b[1] - a[1]);
    
    const heap = [];
    let a;
    let sum = 0;
    
    for(const [s, e] of zip){
        if(heap.length >= k) sum -= pop(heap);
        
        sum += s;
        push(heap, s);
        
        const currP = BigInt(sum) * BigInt(e);
        answer = currP > answer ? currP : answer;
    }
    
    return answer % 1000000007n;
};
```