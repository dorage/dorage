---
uuid: 793256cb-4309-44e2-8ec9-368b95dd5acc
description: 
title: [188]Â Best Time to Buy and Sell Stock IV
tags: [ Daily Challenge, Hard, LeetCode ]
date: 2022-09-09T15:00:00.000Z
---







### ë§í¬

[Best Time to Buy and Sell Stock IV - LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)

### ğŸ“ ë¬¸ì œ

prices ì •ìˆ˜ ë°°ì—´ê³¼ ì •ìˆ˜ kê°€ ì£¼ì–´ì§„ë‹¤.

pricesì˜ ê° ìš”ì†ŒëŠ” i ì¼ì˜ ì£¼ì‹ ê°€ê²©ì´ë‹¤.

ìµœëŒ€ kë²ˆì˜ ê±°ë˜ (ë§¤ìˆ˜ + ë§¤ë„ = 1) ë¡œ ë³¼ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì´ë“ì˜ í•©ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

*INPUT*

*OUTPUT*

```jsx

```

```jsx

```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

ë¸Œë£¨íŠ¸í¬ìŠ¤ë¡œ í’€ì–´ë³´ì•˜ìœ¼ë‚˜ ì—­ì‹œ ì‹œê°„ì´ˆê³¼ì— ê±¸ë¦°ë‹¤.

```tsx
function maxProfit(k: number, prices: number[]): number {
    return recursive(prices, 0, k, undefined);
};

function recursive(prices:number[], i:number, k:number, buy:(number|undefined)) {
    if(buy == null && k === 0 || i >= prices.length) return 0;
    let answer = 0;
    // ì‚¬ì§€ ì•Šì€ ê²½ìš°
    if(buy == null) {
        answer = Math.max(
            recursive(prices, i + 1, k - 1, prices[i]),
            recursive(prices, i + 1, k, undefined),
        );
        return answer;
    }
    // ì‚° ê²½ìš°
        // ë¹„ì‹¼ ê²½ìš°
            // íŒ ê²½ìš°
            // íŒ”ì§€ ì•Šì€ ê²½ìš°
    if(prices[i] > buy) {
        answer = Math.max(
            (prices[i] - buy) + recursive(prices, i + 1, k, undefined),
            recursive(prices, i + 1, k, buy),
        )
    } else {
        return recursive(prices, i + 1, k, buy);
    }
    return answer;
}
```

[A Concise DP Solution in Java - LeetCode Discuss](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/54113/A-Concise-DP-Solution-in-Java)

memo[i][j] = maximum profit from at most i transactions using prices [ 0 .. j ]

j ë§ˆë‹¤ ë‘ ê°œì˜ ì˜µì…˜ì´ ìˆë‹¤.

- ì•„ë¬´ê²ƒë„ (ë§¤ìˆ˜) í•˜ì§€ ì•Šê¸°
    
    dp[i][j] = dp[i][j-1]
    
- ì£¼ì‹ì„ íŒ”ê¸°
    
    í•˜ì§€ë§Œ ì´ë¥¼ ìœ„í•´ì„œëŠ” ì£¼ì‹ì„ [ 0 â€¦ j-1 ] ì— ì‚¬ì•¼ í•œë‹¤.
    ì–»ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì´ë“ì€ t = 0 â€¦ j - 1 | max(prices[j] - prices[t] + dp[i - 1][t - 1])
    prices[j] - prices[t] ëŠ” t ì¼ì— ë§¤ìˆ˜í•˜ê³ , j ì¼ì— ë§¤ë„í–ˆì„ ë•Œì˜ ê¸ˆì•¡ì´ë©°, dp[i - 1][t - 1] ì€ tì¼ ì´ì „ì— ë°œìƒí•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì´ë“ì„ ì˜ë¯¸í•œë‹¤.
    

ìœ„ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(n^2 * k) ì´ë‹¤. (ë°°ì—´ì˜ ìµœëŒ€ ê¸¸ì´ëŠ” 1000, kì˜ ìµœëŒ€ ê°’ì€ 100, ìµœì•…ì˜ ê²½ìš° 1ì–µ ë²ˆì˜ íƒìƒ‰ì„ ì§„í–‰)

ì—¬ê¸°ì„œ ì‹œê°„ë³µì¡ë„ë¥¼ O(n * k) ë¡œ ì¤„ì´ê¸° ìœ„í•´ì„œëŠ” ì£¼ì‹ì„ íŒ” ë•Œ ìµœëŒ€ ì´ìµì„ ê³„ì‚°í•˜ëŠ” t = 0 â€¦ j - 1 | max(prices[j] - prices[t] + dp[i - 1][t - 1]) ìƒìˆ˜ ì‹œê°„ ë‚´ì— í•´ì•¼ í•œë‹¤.

ì—¬ê¸°ì„œ Prices[j] ì˜ ê²½ìš° í˜„ì¬ ìˆœíšŒì¤‘ì¸ ìˆ˜ë¡œ ìƒìˆ˜ë¡œ ì·¨ê¸‰ì´ ê°€ëŠ¥í•˜ë¯€ë¡œ ë‹¤ìŒê³¼ ê°™ì´ ì‹ì„ ë³€ê²½ì´ ê°€ëŠ¥í•˜ë‹¤.

t = 0 â€¦ j - 1 | max(prices[j] + dp[i - 1][t - 1]- prices[t])

prices[j] + t = 0 â€¦ j - 1 | max(- prices[t] + dp[i - 1][t - 1])

(tì¼ ì´ì „ì˜ ìµœëŒ€ ì´ë“ì˜ í•© - tì¼ ë§¤ìˆ˜ ê°€ê²©) + jì¼ ë§¤ë„ ê°€ê²©
ì¦‰, (tì¼ ì´ì „ì˜ ìµœëŒ€ ì´ë“ì˜ í•© - tì¼ ë§¤ìˆ˜ ê°€ê²©) ì´ ìµœëŒ€ì˜ ê°’ì´ ë  ë•Œ ì´ë“ì´ ìµœëŒ€ê°€ ë  ìˆ˜ ìˆë‹¤.

max = Math.max(max, memo[i - 1][j - 1] - prices[j]);

ì´ ë¶€ë¶„ì´ í•­ìƒ j - 1ì¼ ì´ì „ì— (ìµœëŒ€ ì´ë“ - ìµœëŒ€ ì´ë“ì´ ë˜ëŠ” ë§¤ìˆ˜ì‹œê¸°ì˜ ê°€ê²©) ì„ ì¶”ì í•˜ê²Œ ëœë‹¤.

```tsx
function maxProfit(k: number, prices: number[]): number {
    if(!prices.length) return 0;
    const memo:number[][] = Array(k + 1).fill(0).map(()=>Array(prices.length).fill(0));
    
    for(let i = 1; i <= k; i++){
        let max = 0 - prices[0];
        for(let j = 1; j < prices.length; j++){
            memo[i][j] = Math.max(memo[i][j - 1], prices[j] + max);
            max = Math.max(max, memo[i - 1][j - 1] - prices[j]);
        }
    }
    
    return memo[k][prices.length - 1];
};
```