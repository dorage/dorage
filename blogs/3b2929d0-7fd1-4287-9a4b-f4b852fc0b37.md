---
uuid: 3b2929d0-7fd1-4287-9a4b-f4b852fc0b37
description: 
title: [1466]Â Reorder Routes to Make All Paths Lead to the City Zero
tags: [ LeetCode, Medium ]
date: 2022-10-11T15:00:00.000Z
---







### ë§í¬

[Reorder Routes to Make All Paths Lead to the City Zero - LeetCode](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/)

### ğŸ“ ë¬¸ì œ

There areÂ `n`Â cities numbered fromÂ `0`Â toÂ `n - 1`Â andÂ `n - 1`Â roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented byÂ `connections`Â whereÂ `connections[i] = [ai, bi]`Â represents a road from cityÂ `ai`Â to cityÂ `bi`.

This year, there will be a big event in the capital (cityÂ `0`), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the cityÂ `0`. Return theÂ **minimum**Â number of edges changed.

It'sÂ **guaranteed**Â that each city can reach cityÂ `0`Â after reorder.

![Untitled](https://vault-r2.dorage.io/3b2929d0-7fd1-4287-9a4b-f4b852fc0b37/untitled.png)

*INPUT*

*OUTPUT*

```jsx
n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
```

```jsx
3
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

[C++/Java Track Direction - LeetCode Discuss](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/discuss/661672/C%2B%2BJava-Track-Direction)

ê° ë…¸ë“œëŠ” ë‹¤ë¥¸ ë…¸ë“œì™€ ë‹¨ë°©í–¥ìœ¼ë¡œ ì—°ê²°ì´ ë˜ì–´ìˆëŠ” í˜•íƒœì˜ ê·¸ë˜í”„ì´ë‹¤.

ì •ë°©í–¥(ë‚˜ê°€ëŠ” ë°©í–¥)ì„ ìŒìˆ˜ë¡œ ì—­ë°©í–¥(ë“¤ì–´ì˜¤ëŠ” ë°©í–¥)ì„ ì–‘ìˆ˜ë¡œ ê·¸ë˜í”„ì— ì§‘ì–´ë„£ëŠ”ë‹¤.

[0, 1] ì´ë¼ëŠ” connectionì— ëŒ€í•˜ì—¬ 0th ë…¸ë“œëŠ” -1ì„, 1st ë…¸ë“œëŠ” 0ì„ ê°–ê²Œ ëœë‹¤.

ê·¸ë¦¬ê³  0ì—ì„œ BFSë¥¼ ì‹œì‘í•´ì„œ ì—­ë°©í–¥ìœ¼ë¡œ ì´ë™í•  ë•Œë§ˆë‹¤ ë³€ê²½ íšŒìˆ˜ë¥¼ ì¹´ìš´íŠ¸ì—…í•œë‹¤.

```jsx
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var minReorder = function(n, connections) {
    const graph = Array(n).fill().map(()=>[]);
    const visited = new Set();
    
    for(const [a,b] of connections) {
        graph[a].push(-b);
        graph[b].push(a);
    }
    
    const q = [0];
    let answer = 0;
    
    while(q.length) {
        const preq = [];
        while(q.length) {
            const idx = q.shift();
            const abs = Math.abs(idx);
            
            if(visited.has(abs)) continue;
            if(idx < 0) answer++;
            visited.add(abs);

            for(const n of graph[abs]) {
                preq.push(n);
            }
        }
        q.push(...preq);
    }
    
    return answer;
};
```