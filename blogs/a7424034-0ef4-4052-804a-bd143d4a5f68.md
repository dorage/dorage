---
uuid: a7424034-0ef4-4052-804a-bd143d4a5f68
description: 
title: [회고] 더 나은 서비스를 위해 - 스트럭쳐 정리
tags: [  ]
date: 2023-01-14T15:00:00.000Z
---


## 개요

회사가 망했다.

회고 겸, 그간 프로젝트를 리팩토링 했던 기록을 대략 남겨두었던 것을 예쁘게 정리해보기로 했다.

## 문제점

기존의 컴포넌트, 페이지 뭐 할 거 없이 모양이 같으니까 전부 하나의 파일에 기능과 컴포넌트를 모두 때려밖아놓고 조건문으로 분기를 친 코드들…

“모양이 같아 보이는데 받는 형태가 조금 다르네?”

“이건 이럴 땐 이거고 저럴 땐 저거야!”

“이건 shop 페이지의 리스트 요소이지만 다른데도 비슷하니 여기서도 shop의 컴포넌트를 사용할거야!” (컴포넌트의 위치는 /shop 하위에 있음에도 불구하고)

이는 기존에 있던 프론트엔드 개발의 가이드라인이 느슨했던 탓이라는 생각이 들었다.

### **기존 가이드 라인**

**코드 네이밍 컨벤션**

- 컴포넌트는 영문 대문자로 시작하는 카멜케이스를 사용
- 디렉터리 이름과 파일 이름은 모두 영문 소문자로 케밥 케이스를 사용
- 상수는 영문 대문자 스네이크 표기법을 사용

**styled-component 컴포넌트 네이밍 컨벤션**

- 컴포넌트의 가장 바깥쪽을 감싸는 스타일 컴포넌트 네이밍은 Frame으로 통일한다
- 하위 요소가 있는 스타일 컴포넌트는 {name}Wrapper 로 선언한다
- 단일 요소에 스타일 컴포넌트를 적용한다면 {name}{tagname} 으로 선언한다.

 **react-query 및 api 네이밍 컨벤션**

- api의 첫 pathname을 기준으로  queries 디렉터리 하위에 해당 pathname의 디렉터리를 생성하고 그 디렉터리에 모든 api와 해당 api를 사용하는 react-query 함수를 정리한다.
- react-query 함수는 use{api function name} 으로 작성한다

아직 무언가를 주도하기에는 부끄러운 신입의 레벨에서 생각한 구조 들이고, 규칙이다 보니 가끔 이건 어떻게 해야 하지 하는 생각이 문득 문득 들었다.
그리고 내가 잡아 놓은 룰이 오히려 후에 프로젝트가 더 커졌을 때 부채로 다시 찾아오는게 아닌가 하는 생각이 들면 두렵기도 했다. 비록 기술 부채보다 자금 부채가 먼저 왔지만..

## 파일 네이밍과 스트럭쳐

기존 프로젝트의 스트럭처는 다음과 같았다.

![Untitled](https://vault-r2.dorage.io/a7424034-0ef4-4052-804a-bd143d4a5f68/untitled.png)

일단 이미 페이지는 많이 늘어난 상태였고 하나의 페이지는 pages 하위에서 모든 컴포넌트를 조립하고 해당 컴포넌트에 대한 기능을 담당하는 코드들로 뒤엉켜있었다.

hook으로 묶인 기능들도 있었지만, 당연하게 모든 파일에서 동일한 기능을 하는 동일한 코드 로직이 여러 번 보였다.

어떤 게 문제였을까?

지금 생각해보면 hooks, hoc, query, fucntions 이라는 폴더들이 프로젝트 전역에서 공용이라는 느낌이 강했던 것 같다.

해당 디렉터리 하위는 별도의 구분 없이 온갖 곳에서 사용하는 hook, queries, functions, hoc 파일들이 쌓여 있었다.

이렇다 보니 단순히 하나의 페이지에서 사용할 로직들을 지속적으로 넣기에는 나중에 찾기도 힘들고, 어떤 역할을 하는지 알 수 없을 것이라는 부담이 생겼을 수도 있겠구나 라는 생각이 들었다.

실제로 같은 역할을 하는 Hook이 2개 존재하기도 했다.

## 아토믹 디자인

### 왜 아토믹을 선택했는가?

담배 타임에 같이 참여하면서 물어본 질문이다.

Q. ImageAtom은 왜 Atom이 붙나요? Recoil과 관련이 있나요?

A. 개발 초기에 아토믹 디자인을 적용해보려 했던 흔적이다.

검색을 해보니 아토믹 디자인을 구현하며 적었던 아티클이나 아토믹 디자인에 대한 글을 읽을 수 있었다.

완벽한 구현은 없는 멘탈 모델.

안그래도 CBD를 하고 싶어 스토리북을 계속 얘기하고 있었는데 아토믹 디자인에 대한 이야기를 읽어보니 이것만 적용해도 좀 보기 편해지지 않을까 라는 생각이 들었다.

다만, 만든 컴포넌트들을 visualize가 불가능 하다는 점에서 또 다른 문제점을 불러올 수 있다는 부분이 마음에 걸렸지만 이는 추후에 Storybook을 추가하는 걸로 해결하기로 했다.

일단은 추가적인 라이브러리나 프레임워크를 사용하지 않고 컴포넌트 기반의 개발 방법을 모두가 공감할 수 있는 방향으로 정할 수 있다는 것이 좋은 것 같다는 생각이 들었다.

그래서 아토믹 디자인의 네이밍을 차용해서 대략적인 컨셉을 정리하게 되었다.

![개발원칙 v2. 개발을 진행하면서, 특정 컴포넌트가 자신의 바깥쪽 영역을 마진으로 밀어내는 부분이 있어서 컴포넌트의 최상위 요소 바깥은 건드리면 안된다는 조건을 추가하게 되었다.](https://vault-r2.dorage.io/a7424034-0ef4-4052-804a-bd143d4a5f68/v2.png)

개발원칙 v2. 개발을 진행하면서, 특정 컴포넌트가 자신의 바깥쪽 영역을 마진으로 밀어내는 부분이 있어서 컴포넌트의 최상위 요소 바깥은 건드리면 안된다는 조건을 추가하게 되었다.

위 원칙에는 포함이 안되어있지만 가장 중요한 원칙은 ‘공용 컴포넌트를 함부로 만들지 않는다’ 였다.

하나의 컴포넌트가 여러 일을 하기 위해서는 어느 하나의 컴포넌트에 종속되지 않아야 한다.

그래서 같아 보이더라도 페이지를 넘긴다면 코드를 똑같이 복사하는 과정을 수반하더라도 일단은 따로 만들고, 추후에 리팩토링 과정을 통해 공용 컴포넌트에 추가하는 걸 지향하는 방식으로 개발을 하기로 합의했다.

추후에, 이 부분은 컴파운드 컴포넌트들을 구성하면서 문제가 해결이 되었다.

![아토믹네이밍을 차용한 components 하위 스트럭처의 정리 계획안](https://vault-r2.dorage.io/a7424034-0ef4-4052-804a-bd143d4a5f68/components.png)

아토믹네이밍을 차용한 components 하위 스트럭처의 정리 계획안

그리고 무엇보다 이와 동시에 페이지를 기반으로 한 코로케이션(colocation)을 진행하기로 했다.

이유는 단순했다.

**코로케이션을 진행한 이유**

1. 네이밍 문제를 해결하기 편할 것 같았다.
2. 같은 곳에서 일을 하는 것들이 같은 위치에 모여있으니 찾기 편했다.
3. 쉽게 공용과 공용이 아닌 것의 구별이 가능하다

위의 규칙들을 따르니 자연스럽게 아래와 같이 폴더 구조가 변경되었다.

**기존 폴더 구조**

```jsx
compeonents
	- {page}
	- common
hook
constants
contexts

위와 같은 파일스트럭쳐를 page하위로 모두 몰아넣기로 결정을 하게 되었다
```

**새로운 폴더 구조**

```jsx
components
	atomic
	commons (deprecated)
	{page}
		- contexts
		- constants
		- hooks
		- atoms
		- molecules
		- organics
		- templates
		- index.tsx
```

### 어떠한 문제가 사라졌는가?

- 고질적인 문제 해결
    
    단순히 if문으로 분기를 쳐서 여러군데서 사용하던 일들이 없어지고 있다.
    
    페이지가 다르면 일단 새로 생성하고 공용으로 사용할 수 있을지를 판단하는 일은 정말로 좋은 역할을 한다는 생각이 들었다.
    
- 가독성
    
    폴더 구조만으로도 많은 정보를 포함하기 시작했다.
    
    p에 관련되어 있다면 atomic/atoms/p 하위에 있을 컴포넌트라는 것이 명확하다.
    
    shop 폴더 하위에 있는 hook이니 이곳에서만 사용하는 hook이라는 것도 명확하다.
    
- 유지 보수
    
    더 적은 노력을 통해 새로운 기능에 대한 확장이 가능하다.
    
    기존 컴포넌트를 건드리지도 않고, if/else 의 분기도 필요 없이 props의 추가가 가능해졌다.
    
    아주 작은 컴포넌트 단에서 API혹은 값의 상태에 따라 미리 고정된 크기를 잡는 작업을 해주는 것으로, layout shift를 줄일 수 있었다.
    

### 새롭게 생긴 문제점

- 지속적인 리팩토링을 요구
    
    현재 일부 컴포넌트들은 공용 컴포넌트로 구성할 수 있음에도 시간이 부족해서 각 페이지에 따로 존재하는 경우가 있다.
    
    어찌 되었던 리팩토링을 지속적으로 하지 않으면 하나 하나의 컴포넌트의 수정이 너무 많은 시간이 걸릴 수 있었다.
    
- 페이지 기반으로 구분하니 크기가 큰 하나의 컴포넌트가 너무 많은 영역을 차지한다.
    
    예를 들면, 댓글 창이 포함되는 특정 페이지에는 comment라는 prefix를 붙은 컴포넌트가 절반을 넘게 차지하고 있다.
    
    이를 components 하위로 comment라는 폴더를 만들어 빼려고 하니 모두 page 경로의 pathname을 토대로 정리가 되어가고 있는데 comment가 추가 되는 것이 이상하다는 생각이 들었다.
    
    이러한 부분을 해결하기 위해 컴파운드 컴포넌트를 사용하기로 결정했다.
    
- 시안성
    
    별다른 도구 없이 방법론 만을 적용했더니, 이 컴포넌트가 어떠한 형태인지를 확인하기와 내가 원하는 컴포넌트를 찾는 작업이 어려웠다. 그러나 이러한 부분은 새롭게 생긴 문제점은 아니였다.
    

### 다음 문서

