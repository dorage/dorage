---
uuid: adb8d0a5-a673-4db8-a67a-c6ad978c243d
description: 
title: [63]Â Unique Paths II
tags: [ LeetCode, Medium ]
date: 2022-10-20T15:00:00.000Z
---







### ë§í¬

[Unique Paths II - LeetCode](https://leetcode.com/problems/unique-paths-ii/)

### ğŸ“ ë¬¸ì œ

You are given anÂ `m x n`Â integer arrayÂ `grid`. There is a robot initially located at theÂ **top-left corner**Â (i.e.,Â `grid[0][0]`). The robot tries to move to theÂ **bottom-right corner**Â (i.e.,Â `grid[m-1][n-1]`). The robot can only move either down or right at any point in time.

An obstacle and space are marked asÂ `1`Â orÂ `0`Â respectively inÂ `grid`. A path that the robot takes cannot includeÂ **any**Â square that is an obstacle.

ReturnÂ *the number of possible unique paths that the robot can take to reach the bottom-right corner*.

The testcases are generated so that the answer will be less than or equal toÂ `2 * 109`.

*INPUT*

*OUTPUT*

```jsx
obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
```

```jsx
2
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

```jsx
const getMN = (mat) => [mat.length, mat[0].length];

/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    if(obstacleGrid[0][0]) return 0;
    
    const [m, n] = getMN(obstacleGrid);
    const dp = Array(m).fill().map(() => Array(n).fill(0));
    dp[0][0] = 1;
    
    for(let i = 0; i < m; i++) {
        for(let j = 0; j < n; j++) {
            if(obstacleGrid[i][j]) continue;
            if(!i && !j) continue;
            
            dp[i][j] = (i > 0 ? dp[i - 1][j] : 0) +
                (j > 0 ? dp[i][j - 1] : 0);
        }
    }
    
    return dp[m - 1][n - 1];
};
```