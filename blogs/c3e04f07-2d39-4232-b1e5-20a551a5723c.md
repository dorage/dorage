---
uuid: c3e04f07-2d39-4232-b1e5-20a551a5723c
description: 
title: [127]Â Word Ladder
tags: [ Hard, LeetCode ]
date: 2022-10-13T15:00:00.000Z
---







### ë§í¬

[Word Ladder - LeetCode](https://leetcode.com/problems/word-ladder/)

### ğŸ“ ë¬¸ì œ

AÂ **transformation sequence**Â from wordÂ `beginWord`Â to wordÂ `endWord`Â using a dictionaryÂ `wordList`Â is a sequence of wordsÂ `beginWord -> s1Â -> s2Â -> ... -> sk`Â such that:

- Every adjacent pair of words differs by a single letter.
- EveryÂ `si`Â forÂ `1 <= i <= k`Â is inÂ `wordList`. Note thatÂ `beginWord`Â does not need to be inÂ `wordList`.
- `skÂ == endWord`

Given two words,Â `beginWord`Â andÂ `endWord`, and a dictionaryÂ `wordList`, returnÂ *theÂ **number of words**Â in theÂ **shortest transformation sequence**Â from*Â `beginWord`Â *to*`endWord`*, or*Â `0`Â *if no such sequence exists.*

*INPUT*

*OUTPUT*

```jsx

```

```jsx

```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

```jsx
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function(beginWord, endWord, wordList) {
    wordList = new Set(wordList);
    if(!wordList.has(endWord)) return 0;
    
    const q = [beginWord];
    const visited = new Set();
    let count = 0;
    
    while(q.length) {
        const preq = [];
        count++;
        while(q.length) {
            const str = q.shift();
            
            if(str === endWord) return count;
            if(visited.has(str)) continue;
            visited.add(str);
            
            preq.push(...generateMutations(str, wordList));
        }
        q.push(...preq);
    }
    
    return 0;
};

const getLowerCode = (n) => n + 'a'.charCodeAt();
const codeToChar = (n) => String.fromCharCode(n);

const generateMutations = (str, possibles) => {
    const len = str.length;
    const muts = [];
    for(let i = 0; i < len; i++) {
        for(let j = 0; j < 26; j++) {
            const mut = str.slice(0, i) + codeToChar(getLowerCode(j)) + str.slice(i + 1, len);
            if(!possibles.has(mut)) continue;
            muts.push(mut);
        }
    }
    return muts;
}
```