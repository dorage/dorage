---
uuid: 3dfd4727-68a9-4349-bdd7-1babdef8a735
description: 
title: [2462]Â Total Cost to Hire K Workers
tags: [ Contest, LeetCode, Medium ]
date: 2022-11-05T15:00:00.000Z
---







### ë§í¬

[](https://leetcode.com/problems/total-cost-to-hire-k-workers/description/)

### ğŸ“ ë¬¸ì œ

You are given aÂ **0-indexed**Â integer arrayÂ `costs`Â whereÂ `costs[i]`Â is the cost of hiring theÂ `ith`Â worker.

You are also given two integersÂ `k`Â andÂ `candidates`. We want to hire exactlyÂ `k`Â workers according to the following rules:

- You will runÂ `k`Â sessions and hire exactly one worker in each session.
- In each hiring session, choose the worker with the lowest cost from either the firstÂ `candidates`Â workers or the lastÂ `candidates`Â workers. Break the tie by the smallest index.
    - For example, ifÂ `costs = [3,2,7,7,1,2]`Â andÂ `candidates = 2`, then in the first hiring session, we will choose theÂ `4th`Â worker because they have the lowest costÂ `[3,2,7,7,**1**,2]`.
    - In the second hiring session, we will chooseÂ `1st`Â worker because they have the same lowest cost asÂ `4th`Â worker but they have the smallest indexÂ `[3,**2**,7,7,2]`. Please note that the indexing may be changed in the process.
- If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.
- A worker can only be chosen once.

ReturnÂ *the total cost to hire exactly*Â `k`Â *workers.*

*INPUT*

*OUTPUT*

```jsx
costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
```

```jsx
4
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

ë¬¸ì œë¥¼ ì´í•´ë¥¼ ëª»í•´ì„œ ëª» í’€ì—ˆë‹¤. ê·¸ë˜ì„œ ë” ì•„ì‰½ë‹¤.

ì¶”ì²œì„ 3ë²ˆì§¸ë¡œ ë§ì´ ë°›ì€ ì˜ê²¬ì´ ì´ê²Œ ë¬´ìŠ¨ ë‹µì„ êµ¬í•˜ëƒëŠ” ì˜ê²¬ì´ë‹ˆ..

ë°°ì—´ì˜ ì‹œì‘ê³¼ ëì—ì„œ candidatesì˜ ìš”ì†Œì˜ ê°œìˆ˜ë§Œí¼ ë¶€ë¶„ ë°°ì—´ì„ ë§Œë“¤ê³  sortí•œ ë’¤ ë” ì‘ì€ ìˆ˜ë¥¼ ë¹¼ê³  ì¤‘ê°„ ê°’ì—ì„œ í•˜ë‚˜ ì”© ê°€ì ¸ì™€ ì´ì§„ íƒìƒ‰ì„ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì´í–ˆë‹¤.

```jsx
const binSearch = (arr, target) => {
    let l = 0;
    let r = arr.length - 1;

    while (l <= r) {
        const mid = Math.floor((l + r) / 2);

        if (arr[mid] > target) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return l;
};

/**
 * @param {number[]} costs
 * @param {number} k
 * @param {number} candidates
 * @return {number}
 */
var totalCost = function(costs, k, candidates) {
    if(costs.length <= candidates * 2) return costs.sort((a,b)=>a-b).slice(0, k).reduce((a,c)=>a+c,0);

    const left = costs.slice(0, candidates);
    const middle = costs.slice(candidates, costs.length - candidates);
    const right = costs.slice(costs.length - candidates, costs.length);
    left.sort((a,b)=>a-b);
    right.sort((a,b)=>a-b);

    const selected = [];

    while(selected.length < k) {
        if(left[0] <= right[0]) {
            selected.push(left.shift());
            const n = middle.shift();
            left.splice(binSearch(left, n), 0, n);
        }
        else {
            selected.push(right.shift());
            const n = middle.pop();
            right.splice(binSearch(right, n), 0, n);
        }
    }
    
    return selected.reduce((a,c)=>a+c,0);
};
```