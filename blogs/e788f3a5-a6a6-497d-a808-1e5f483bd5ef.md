---
uuid: e788f3a5-a6a6-497d-a808-1e5f483bd5ef
description: 
title: [1293]Â Shortest Path in a Grid with Obstacles Elimination
tags: [ Daily Challenge, Hard, LeetCode ]
date: 2022-10-29T15:00:00.000Z
---







### ë§í¬

### ğŸ“ ë¬¸ì œ

You are given anÂ `m x n`Â integer matrixÂ `grid`Â where each cell is eitherÂ `0`Â (empty) orÂ `1`Â (obstacle). You can move up, down, left, or right from and to an empty cell inÂ **one step**.

ReturnÂ *the minimum number ofÂ **steps**Â to walk from the upper left corner*Â `(0, 0)`Â *to the lower right corner*Â `(m - 1, n - 1)`Â *given that you can eliminateÂ **at most***Â `k`Â *obstacles*. If it is not possible to find such walk returnÂ `-1`.

![Untitled](https://vault-r2.dorage.io/e788f3a5-a6a6-497d-a808-1e5f483bd5ef/untitled.png)

*INPUT*

*OUTPUT*

```jsx
grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
```

```jsx
6
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

ì²˜ìŒì—ëŠ” ìŠ¤íŠ¸ë§ì„ ì´ìš©í•´ ì €ì¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í’€ì´í•´ë³´ì•˜ëŠ”ë° ë©”ëª¨ë¦¬ ì´ˆê³¼ë¡œ í’€ì´í•˜ì§€ ëª»í–ˆë‹¤.

ê·¸ë˜ì„œ ìŠ¤íŠ¸ë§ì„ BigIntë¡œ ë³€ê²½í•˜ì—¬ BigIntë¥¼ ë¹„íŠ¸ë§ˆìŠ¤í‚¹í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ í’€ì´í•´ë³´ì•˜ëŠ”ë° ì´ëŠ” ì‹œê°„ ì´ˆê³¼ì˜ ë¬¸ì œë¥¼ ê²ªì—ˆë‹¤.

ìƒê°ì„ í•´ë³´ë‹ˆ ì´ëŠ” BFSì´ê¸° ë•Œë¬¸ì— ê° ì´ë™ë“¤ì— ëŒ€í•œ visited ì²´í¬ë¥¼ ë‹¨ë…ìœ¼ë¡œ í•˜ë©´ ì•ˆëœë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤. * ë‹¤ì‹œ ë’¤ë¡œ ë˜ëŒì•„ê°€ëŠ” ê²½ìš°ë¥¼ ì œì™¸í•´ì•¼ í•œë‹¤.

ë”°ë¼ì„œ ê°™ì€ k íšŸìˆ˜ì˜ ë²½ëŒê¹¨ê¸°ê°€ ë‚¨ì€ ê²½ìš°ì¼ ë•Œ ì´ë¯¸ ì§€ë‚˜ê°„ ê²½ë¡œëŠ” ë¬´ì‹œí•˜ëŠ” ë°©í–¥ìœ¼ë¡œ í’€ì´ë¥¼ í•˜ê²Œ ë˜ì—ˆë‹¤.

visitedì˜ ìµœëŒ€ í¬ê¸°ê°€ 2,560,000 ì„ ì°¨ì§€í•˜ëŠ”ë° ì´ê²Œ ì•ˆí„°ì§ˆê¹Œ ì‹¶ì—ˆì§€ë§Œ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ì— ì•„ë§ˆ ì´ëŸ° ê²½ìš°ê°€ ì—†ì—ˆë˜ ê²ƒ ê°™ë‹¤.

**visitedë¥¼ ê°ì ê°–ê³  ìˆê³  ì´ë¥¼ ìŠ¤íŠ¸ë§ìœ¼ë¡œ ì €ì¥í•œ ê²½ìš° (Memory Limit Exceeded)**

```jsx
const getMN = (grid) => [grid.length, grid[0].length];

const get2DtoLinearIdx = (grid, i, j) => {
    const [m] = getMN(grid);
    return i * m + j;
}

const getNextQElem = (grid, i, j, k, visited) => {
    const [m, n] = getMN(grid);
    const idx = get2DtoLinearIdx(grid, i, j);
    if(visited[idx] === '1') return null;
    
    const newVisited = visited.slice(0, idx) + '1' + visited.slice(idx + 1, m * n);
    if(grid[i][j]) {
        if(k) return [[i, j], k - 1, newVisited];
        return null;
    }
    return [[i, j], k, newVisited];
}

/**
 * @param {number[][]} grid
 * @param {number} k
 * @return {number}
 */
var shortestPath = function(grid, k) {
    const [m, n] = getMN(grid);
    const q = [[[0,0], k, '1' + '0'.repeat(m * n - 1)]];
    
    let dist = 0;
    
    while(q.length) {
        const preq = [];
        while(q.length) {
            const [[i, j], k, vistied] = q.shift();
            
            if(i === m - 1 && j === n - 1) return dist;
            
            if(i > 0) {
                const elem = getNextQElem(grid, i - 1, j, k, vistied);
                if(elem) preq.push(elem);
            }
            if(i < m - 1) {
                const elem = getNextQElem(grid, i + 1, j, k, vistied);
                if(elem) preq.push(elem);
            }
            if(j > 0) {
                const elem = getNextQElem(grid, i, j - 1, k, vistied);
                if(elem) preq.push(elem);
            }
            if(j < n - 1) {
                const elem = getNextQElem(grid, i, j + 1, k, vistied);
                if(elem) preq.push(elem);
            }
        }
        q.push(...preq);
        dist++;
    }
    return -1;
};
```

**visitedë¥¼ ëª¨ë‘ê°€ ê³µìœ í•˜ê³  kì˜ íšŸìˆ˜ì— ë”°ë¥¸ visitedë¥¼ ì²´í¬ (Success)**

```jsx
const getMN = (grid) => [grid.length, grid[0].length];

const getNextQElem = (grid, i, j, k) => {
    if(!grid[i][j]) return [i, j, k];
    if(k) return [i, j, k - 1];
    return null;
}

/**
 * @param {number[][]} grid
 * @param {number} k
 * @return {number}
 */
var shortestPath = function(grid, k) {
    const [m, n] = getMN(grid);
    const q = [[0, 0, k]];
    const visited = Array(k + 1).fill().map(() => Array(m).fill().map(()=>Array(n).fill(false)));
    let dist = 0;
    
    while(q.length) {
        const preq = [];
        while(q.length) {
            const [i, j, k] = q.shift();
            
            if(i === m - 1 && j === n - 1) return dist;
            if(visited[k][i][j]) continue;
            visited[k][i][j] = true;
            
            if(i > 0) {
                const elem = getNextQElem(grid, i - 1, j, k);
                if(elem) preq.push(elem);
            }
            if(i < m - 1) {
                const elem = getNextQElem(grid, i + 1, j, k);
                if(elem) preq.push(elem);
            }
            if(j > 0) {
                const elem = getNextQElem(grid, i, j - 1, k);
                if(elem) preq.push(elem);
            }
            if(j < n - 1) {
                const elem = getNextQElem(grid, i, j + 1, k);
                if(elem) preq.push(elem);
            }
        }
        q.push(...preq);
        dist++;
    }
    return -1;
};
```