---
uuid: bed04797-409c-40f0-b145-3fc67ad7f1f5
description: 
title: [2435]Â Paths in Matrix Whose Sum Is Divisible by K
tags: [ Contest, Hard, LeetCode ]
date: 2022-10-09T15:00:00.000Z
---







### ë§í¬

[Paths in Matrix Whose Sum Is Divisible by K - LeetCode](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/)

### ğŸ“ ë¬¸ì œ

You are given aÂ **0-indexed**Â `m x n`Â integer matrixÂ `grid`Â and an integerÂ `k`. You are currently at positionÂ `(0, 0)`Â and you want to reach positionÂ `(m - 1, n - 1)`moving onlyÂ **down**Â orÂ **right**.

ReturnÂ *the number of paths where the sum of the elements on the path is divisible by*Â `k`. Since the answer may be very large, return itÂ **modulo**Â `109Â + 7`.

*INPUT*

*OUTPUT*

```jsx
s = "zza"
```

```jsx
"azz"
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

dpë¥¼ ì´ìš©í•˜ì—¬ í’€ì´í•˜ì˜€ë‹¤.

ì²˜ìŒì—ëŠ” mapì˜ keyë¥¼ ë‹¨ìˆœíˆ grid[i + 1][j] ì™€ grid[i][j + 1] ìœ¼ë¡œ ì¡ì•„ì„œ í–ˆë”ë‹ˆ ë©”ëª¨ë¦¬ê°€ í„°ì§€ëŠ” ë¬¸ì œê°€ ê³„ì† ë°œìƒí–ˆë‹¤.

ìƒê°í•´ë³´ë‹ˆ í•­ìƒ kë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ keyë¡œ ì¡ìœ¼ë©´ kì˜ ë²”ìœ„ê°€ 50ìœ¼ë¡œ í•œì •ì´ ë˜ì–´ ìˆì–´, ìµœëŒ€ ë©”ëª¨ë¦¬ ê³µê°„ 50 * 50,000 ì„ ì°¨ì§€í•œë‹¤.

```jsx
const getMN = (grid) => [grid.length, grid[0].length];

/**
 * @param {number[][]} grid
 * @param {number} k
 * @return {number}
 */
var numberOfPaths = function(grid, k) {
    const [m, n] = getMN(grid);
    const MOD = 10 ** 9 + 7;
    const dp = Array(m).fill().map(() => Array(n).fill());
    
    dp[m - 1][n - 1] = new Map();
    dp[m - 1][n - 1].set(grid[m - 1][n - 1] % k, 1);
    
    for(let i= m - 1; i >= 0; i--){
        for(let j = n - 1; j >= 0; j--) {
            if(i === m - 1 && j === n - 1) continue;
            
            const map = new Map();
            const num = grid[i][j];
            
            if(i + 1 < m) {
                const keys = dp[i + 1][j].keys();
                for(const key of keys) {
                    const newKey = (key + num) % k;
                    const newVal = dp[i + 1][j].get(key);
                    map.set(newKey, newVal % MOD);
                }
            }
            if(j + 1 < n) {
                const keys = dp[i][j + 1].keys();
                for(const key of keys) {
                    const newKey = (key + num) % k;
                    const newVal = (map.has(newKey) ? map.get(newKey) : 0)
                                        + dp[i][j + 1].get(key)
                    map.set(newKey, newVal % MOD);
                }
            }
            
            dp[i][j] = map;
        }
    }
    
    return dp[0][0].has(0) ? dp[0][0].get(0) : 0;
};
```