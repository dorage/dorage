---
uuid: 83a9e9ca-ac71-4011-a98a-853928b2b7a7
description: 
title: JS의 부동소수점
tags: [  ]
date: 2021-03-01T15:00:00.000Z
---







JS의 숫자형은 64비트로 인코딩된 배정밀도의(double-precision) 부동소수점이다.

이는 53비트까지의 정확도로 완벽하게 integer를 표현할 수 있다.

2^-53 ~ 2^53 (대략 15자리 9, 1천조) 까지의 모든 integer가 유효한 double값이다.

따라서 자바스크립트에서 integer 연산은 별도의 integer형 없이도 완벽하게 가능하다.

하지만 비트단위 연산자는 특별한 점이 있다.

암묵적으로 32비트 정수로 변환하여 계산한뒤 다시 부동소수점으로 변환하여 리턴한다.

```jsx
8 | 1; // 9
/// 00000000000000000000000000001000
/// 00000000000000000000000000000001
/// 00000000000000000000000000001001
15 & 5; // 5
/// 00000000000000000000000000001111
/// 00000000000000000000000000000101
/// 00000000000000000000000000000101
```

double 은 실수에 비해 유한한 숫자범위만 표현할 수 있다.

부동소수점 산술연산은 근사값만을 만들어낼 수 있고 가장 가까운 표현가능한 실수로 반올림한다.

따라서 계산을 계속 수행하다 보면 반올림 오류가 누적되어 더욱 더 부정확한 결과를 낳게 된다.

```jsx
(0.1 + 0.2) + 0.3; // 0.6000000000000001
0.1 + (0.2 + 0.3); // 0.6
0.1 + 0.2 === 0.3 // false
```

따라서 가능한 정수값을 이용하여 계산을 처리해야한다.

다만 정수 값을 처리할 때도 모든 연산은 2^-53 ~ 2^53 범위내에 맞춰진다는 것을 염두해야 한다.

```jsx
Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON // true
```

**Number.EPSILON**

1과 1보다 큰 수 중 가장 작은 수의 차