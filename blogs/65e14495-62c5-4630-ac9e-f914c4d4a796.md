---
uuid: 65e14495-62c5-4630-ac9e-f914c4d4a796
description: 
title: [2452]Â Words Within Two Edits of Dictionary
tags: [ Contest, LeetCode, Medium ]
date: 2022-10-29T15:00:00.000Z
---







### ë§í¬

[Words Within Two Edits of Dictionary - LeetCode](https://leetcode.com/problems/words-within-two-edits-of-dictionary/)

### ğŸ“ ë¬¸ì œ

You are given two string arrays,Â `queries`Â andÂ `dictionary`. All words in each array comprise of lowercase English letters and have the same length.

In oneÂ **edit**Â you can take a word fromÂ `queries`, and change any letter in it to any other letter. Find all words fromÂ `queries`Â that, after aÂ **maximum**Â of two edits, equal some word fromÂ `dictionary`.

ReturnÂ *a list of all words from*Â `queries`*,Â that match with some word from*Â `dictionary`Â *after a maximum ofÂ **two edits***. Return the words in theÂ **same order**Â they appear inÂ `queries`.

*INPUT*

*OUTPUT*

```jsx
queries = ["word","note","ants","wood"], dictionary = ["wood","joke","moat"]
```

```jsx
["word","note","wood"]
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

ì²˜ìŒì—” BFSì¸ê°€ ì‹¶ì—ˆë‹¤.

í•˜ì§€ë§Œ ìƒê°ì„ í•´ë³´ë©´ í•˜ë‚˜ì˜ wordì˜ ê¸¸ì´ê°€ ìµœëŒ€ 100 ì´ ë˜ê¸° ëŒ€ë¬¸ì— ìµœì•…ì˜ ê²½ìš° (25 ** 2) * (100 * (100 - 1)) / 2 = 3,000,000 ë²ˆì˜ ì—°ì‚°ì´ í•„ìš”í•˜ë‹¤.

ì§€ê¸ˆ ìƒê°í•´ë³´ë©´ ê·¸ë¦¬ í° ìˆ˜ëŠ” ì•„ë‹ˆì§€ë§Œ ë” ê°„ë‹¨í•œ ë°©ë²•ì´ ìˆë‹¤ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤.

Trieì— ëª¨ë“  dictionary ë‚´ì˜ ë‹¨ì–´ë¥¼ ì €ì¥í•œ ë‹¤ìŒ ì°¾ëŠ”ë‹¤ë©´ ë” ê°„ë‹¨í•˜ì§€ ì•Šì„ê¹Œ ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆë‹¤.

Trieë¡œ ë§Œë“¤ì–´ ì¤€ ë’¤ DFSë¥¼ í†µí•´ Trieë¥¼ íƒìƒ‰í–ˆë‹¤.

```jsx
const charcode = (ch) => ch.charCodeAt() - 'a'.charCodeAt();

const Trie = function () {
    if(!new.target) return new Trie();
    this.next = Array(26).fill(null);
};

const DFS = (curr, str, idx, max) => {
    if(max < 0) return false;
    if(idx >= str.length) return true;
    const code = charcode(str[idx]);
    
    for(let i = 0; i < 26; i++) {
        if(curr.next[i] == null) continue;
        
        let bfs = i === code ? 
            BFS(curr.next[i], str, idx + 1, max):
            BFS(curr.next[i], str, idx + 1, max - 1);
        if(bfs) return true;
    }
    return false;
};

/**
 * @param {string[]} queries
 * @param {string[]} dictionary
 * @return {string[]}
 */
var twoEditWords = function(queries, dictionary) {
    const result = [];
    const trie = Trie();
    
    for(let i = 0; i < dictionary.length; i++) {
        const d = dictionary[i];
        const n = d.length;
        
        let curr = trie;
        for(let j = 0; j < n; j++) {
            const ch = d[j];
            const idx = charcode(ch);
            if(!curr.next[idx]) {
                const temp = Trie();
                curr.next[charcode(ch)] = temp;
            }
            curr = curr.next[idx];
        }
    }
    
    for(let i = 0; i < queries.length; i++) {
        const q = queries[i];
        if(DFS(trie, q, 0, 2)) result.push(q);
    }
    return result;
};
```