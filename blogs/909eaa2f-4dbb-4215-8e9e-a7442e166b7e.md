---
uuid: 909eaa2f-4dbb-4215-8e9e-a7442e166b7e
description: 
title: [376]Â Wiggle Subsequence
tags: [ LeetCode, Medium ]
date: 2022-10-22T15:00:00.000Z
---







### ë§í¬

[Wiggle Subsequence - LeetCode](https://leetcode.com/problems/wiggle-subsequence/)

### ğŸ“ ë¬¸ì œ

AÂ **wiggle sequence**Â is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.

- For example,Â `[1, 7, 4, 9, 2, 5]`Â is aÂ **wiggle sequence**Â because the differencesÂ `(6, -3, 5, -7, 3)`Â alternate between positive and negative.
- In contrast,Â `[1, 4, 7, 2, 5]`Â andÂ `[1, 7, 4, 5, 5]`Â are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.

AÂ **subsequence**Â is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.

Given an integer arrayÂ `nums`, returnÂ *the length of the longestÂ **wiggle subsequence**Â of*Â `nums`.

*INPUT*

*OUTPUT*

```jsx
nums = [1,7,4,9,2,5]
```

```jsx
6
```

### ğŸš¨ ì˜¤ë¥˜

<aside>
ğŸ•§

</aside>

### âœ”ï¸ í’€ì´

```jsx
/**
 * @param {number[]} nums
 * @return {number}
 */
var wiggleMaxLength = function(nums) {
    const len = nums.length;
    const memo = {
        up: Array(len).fill(0),
        down: Array(len).fill(0)
    }
    
    let max = 0;
    
    for(let i = 0; i < len; i++) {
        max = Math.max(
            max,
            traverse(nums, i, true, memo),
            traverse(nums, i, false, memo)
        );
    }
    
    return max;
};

const traverse = (nums, i, isUp, memo) => {
    if(isUp) {
        if(!memo.up[i]) {
            let max = 1;
            for(let j = i + 1; j < nums.length; j++) {
                if(nums[j] <= nums[i]) continue;
                max = Math.max(max, 1 + traverse(nums, j, !isUp, memo));
            }
            memo.up[i] = max;
        }
        return memo.up[i];
    } else {
        if(!memo.down[i]) {
            let max = 1;
            for(let j = i + 1; j < nums.length; j++) {
                if(nums[j] >= nums[i]) continue;
                max = Math.max(max, 1 + traverse(nums, j, !isUp, memo));
            }
            memo.down[i] = max;
        }
        return memo.down[i];
    }
};
```